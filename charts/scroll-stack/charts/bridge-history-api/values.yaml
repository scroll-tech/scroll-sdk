global:
  nameOverride: &app_name bridge-history-api
  fullnameOverride: *app_name

controller:
  replicas: 1
  strategy: RollingUpdate
  type: deployment

image:
  repository: scrolltech/bridgehistoryapi-api
  pullPolicy: Always
  tag: v4.4.0

command:
  [
    "/bin/sh",
    "-c",
    "bridgehistoryapi-api --config /app/conf/bridge-history-config.json --metrics --metrics.addr 0.0.0.0 --metrics.port ${METRICS_PORT} --log.debug",
  ]

env:
  - name: METRICS_PORT
    value: "8090"

service:
  main:
    enabled: true
    ports:
      http:
        enabled: true
        port: 8080
      metrics:
        enabled: true
        port: 8090
        targetPort: 8090
    annotations:
      external-dns.alpha.kubernetes.io/hostname: scroll-stack-bridge-history-api.devnet.scroll.tech
      service.beta.kubernetes.io/aws-load-balancer-proxy-protocol: "*"
      service.beta.kubernetes.io/aws-load-balancer-type: nlb
      service.beta.kubernetes.io/aws-load-balancer-internal: "true"
    type: LoadBalancer
    
persistence:
  bridge-history-api:
    enabled: yes
    type: configMap
    mountPath: /app/conf/
    name: bridge-history-config

resources:
  requests:
    memory: "100Mi"
    cpu: "50m"
  limits:
    memory: "500Mi"
    cpu: "100m"

defaultProbes: &default_probes
  enabled: true
  custom: true
  spec:
    httpGet:
      path: "/health"
      port: 8090

probes:
  liveness:
    <<: *default_probes
  readiness:
    <<: *default_probes
  startup:
    <<: *default_probes

# this api is a read-only service, it doesn't need to init and migrate again, since all db procedures are finished in fetcher

additionalContainers:
  redis:
    name: redis
    image: redis

serviceMonitor:
  main:
    enabled: true
    labels:
      release: scroll-stack
    serviceName: '{{ include "bjw-s.common.lib.chart.names.fullname" $ }}'
    endpoints:
      - port: metrics
        interval: 1m
        scrapeTimeout: 10s